#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Quick and Dirty password generator.
"""

# Credits
__author__ = 'George Flanagin'
__copyright__ = 'Copyright 2017, University of Richmond'
__credits__ = None
__version__ = '1.0'
__maintainer__ = 'George Flanagin'
__email__ = 'gflanagin@richmond.edu'
__status__ = 'Working Prototype'
__required_version__ = 3.4


# These are system packages, and there are no python environments
# that do not have them present.
import argparse
import math
import os
import platform
import random
import string
import sys

if sys.version_info < (3,3):
    print('You need Python 3.3+ to run this program.')
    sys.exit(os.EX_SOFTWARE)

default_alphabet = string.ascii_letters + string.digits + '/+=!~-?'

where_am_i = platform.system()
if where_am_i == 'Linux':
    dictionary_location = '/usr/share/dict/words'
elif where_am_i == 'Darwin':
    dictionary_location = '/usr/share/dict/web2'
else:
    dictionary_location = ''


def make_safe(s:str,a:str) -> str:
    """
    UR's experience is that lower case ells and cap O create problems.
    Swap l for L and O for o, and then swap anything not in the
    allowed alphabet for something that is. Note that this substitution
    does not meaningfully change anything -- it's a random exchange.
    """
    s = s.replace('l','L')
    s = s.replace('O', 'o')
    for i in range(0, len(s)):
        if s[i] not in a:
            s = s.replace(s[i], random.choice(a))

    return s


def password_gen(my_args:argparse.Namespace) -> list:
    """
    The business routine. 
    """
    passwords = []

    with open(my_args.words) as f:
        words = set(f.read().split())

    try:
        word_bits = math.log(len(words),2)
    except:
        word_bits = 0

    # Make a list of the sources so that we can randomly
    # choose a source and then randomly choose something within
    # the source.
    sources = []

    if len(words): sources.append((words, word_bits))
    sources.append(
        (set(string.ascii_letters), math.log(len(string.ascii_letters),2))
        )
    sources.append(
        (set(string.digits), math.log(len(string.digits),2))
        )
    sources.append(
        (set(string.punctuation), math.log(len(string.punctuation),2))
        )

    for i in range(0, my_args.number):
        password = ''
        entropic_bits = 0.0
        
        # We need a password that is long enough and improbable enough...
        while (entropic_bits < my_args.bits or len(password) < my_args.min_length):
            target = random.choice(sources)
            password += random.sample(target[0],1)[0]
            entropic_bits += target[1]
        else:        
            passwords.append((make_safe(password,my_args.alphabet), entropic_bits))
        
    return passwords
            

def do_help() -> None:
    """
    Usage: passwords [opts]

    Options are:

        -? / --help : you are reading it.
        -n / --number : how many passwords do you want? defaults to 10.
        -z / --min-length : how long must each password be? defaults to 16
        -a / --alphabet : allowed chars in password, defaults to quite
            a few of the printable characters.
        -w / --words : location of the dictionary file.
        -b / --bits : bits of "entropy" required in each password. YES YES
            I know this is not even sort of what is meant by 'entropy' in
            physics, but I also know the word has taken root and it is
            a measure of like, like something. Whatever. Actually. 

    Prints the options and a list of passwords. Example:

    Passwords generated by using the following options:

      --alphabet abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789/+=!~-? --bits 50 --min-length 20 --number 10 --words /usr/share/dict/words

         :: Password                                 :: Len ::   Bits
    ================================================================================
       0 :: thioLsprocainesj~emboss                  ::  23 ::   67.3
       1 :: sonspoLypharmacysLicker                  ::  23 ::   56.6
       2 :: coLLaborate6qTzhrepeaL                   ::  22 ::   63.2
       3 :: 0Kedahe1w1UsteeLieso                     ::  20 ::   69.8
       4 :: 4fribbLery320disputativeLy               ::  26 ::   52.7
       5 :: BaenmuffLeBhydrorrhoea                   ::  22 ::   52.7
       6 :: 2puLsestymetatrophyC                     ::  20 ::   56.1
       7 :: XbH0o7uLtraspLendid7                     ::  20 ::   50.2
       8 :: 6osUisZtYPhascoLonus                     ::  20 ::   65.7
       9 :: 65unquietestq1creinvents                 ::  24 ::   59.1

         
    """
    print(do_help.__doc__)
    sys.exit(os.EX_OK)


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument('-?', '--h', action='store_true')
    parser.add_argument('-n', '--number', type=int, default=10)
    parser.add_argument('-z', '--min-length', type=int, default=16)
    parser.add_argument('-a', '--alphabet', type=str, 
        default=default_alphabet)
    parser.add_argument('-w', '--words', type=str, 
        default=dictionary_location)
    parser.add_argument('-b', '--bits', type=int, default=50)
    my_args = parser.parse_args()
    if my_args.h: do_help()
    passwords = password_gen(my_args)

    print("\nPasswords generated by using the following options:\n")
    opt_string = ' '
    for _ in sorted(vars(my_args).items()):
        opt_string += " --"+ _[0].replace("_","-") + " " + str(_[1])
    print(opt_string + "\n")

    print(" :: ".join([
        '    ',
        'Password'.ljust(40),
        'Len',
        'Bits'.rjust(6)
        ]))
    print("="*80)
    for i in range(0, len(passwords)):
        p = passwords[i]
        print(" :: ".join([
            str(i).rjust(4), 
            p[0].ljust(40), 
            str(len(p[0])).rjust(3),
            str(round(p[1],1)).rjust(6)
            ]))
else:
    print('password_gen compiled')
